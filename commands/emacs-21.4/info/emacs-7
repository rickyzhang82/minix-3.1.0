This is ../info/emacs, produced by makeinfo version 4.3 from emacs.texi.

   This is the Fourteenth edition of the `GNU Emacs Manual', updated
for Emacs version 21.3.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C)
1985,1986,1987,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002
Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto", "Distribution" and "GNU
GENERAL PUBLIC LICENSE", with the Front-Cover texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: emacs,  Node: Incremental Search,  Next: Nonincremental Search,  Prev: Search,  Up: Search

Incremental Search
==================

   An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string, Emacs
shows you where the string (as you have typed it so far) would be
found.  When you have typed enough characters to identify the place you
want, you can stop.  Depending on what you plan to do next, you may or
may not need to terminate the search explicitly with <RET>.

`C-s'
     Incremental search forward (`isearch-forward').

`C-r'
     Incremental search backward (`isearch-backward').

   `C-s' starts a forward incremental search.  It reads characters from
the keyboard, and moves point past the next occurrence of those
characters.  If you type `C-s' and then `F', that puts the cursor after
the first `F' (the first following the starting point, since this is a
forward search).  Then if you type an `O', you will see the cursor move
just after the first `FO' (the `F' in that `FO' may or may not be the
first `F').  After another `O', the cursor moves after the first `FOO'
after the place where you started the search.  At each step, the buffer
text that matches the search string is highlighted, if the terminal can
do that; the current search string is always displayed in the echo area.

   If you make a mistake in typing the search string, you can cancel
characters with <DEL>.  Each <DEL> cancels the last character of search
string.  This does not happen until Emacs is ready to read another
input character; first it must either find, or fail to find, the
character you want to erase.  If you do not want to wait for this to
happen, use `C-g' as described below.

   When you are satisfied with the place you have reached, you can type
<RET>, which stops searching, leaving the cursor where the search
brought it.  Also, any command not specially meaningful in searches
stops the searching and is then executed.  Thus, typing `C-a' would
exit the search and then move to the beginning of the line.  <RET> is
necessary only if the next command you want to type is a printing
character, <DEL>, <RET>, or another character that is special within
searches (`C-q', `C-w', `C-r', `C-s', `C-y', `M-y', `M-r', `M-s', and
some other meta-characters).

   Sometimes you search for `FOO' and find one, but not the one you
expected to find.  There was a second `FOO' that you forgot about,
before the one you were aiming for.  In this event, type another `C-s'
to move to the next occurrence of the search string.  You can repeat
this any number of times.  If you overshoot, you can cancel some `C-s'
characters with <DEL>.

   After you exit a search, you can search for the same string again by
typing just `C-s C-s': the first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again."

   To reuse earlier search strings, use the "search ring".  The
commands `M-p' and `M-n' move through the ring to pick a search string
to reuse.  These commands leave the selected search ring element in the
minibuffer, where you can edit it.  Type `C-s' or `C-r' to terminate
editing the string and search for it.

   If your string is not found at all, the echo area says `Failing
I-Search'.  The cursor is after the place where Emacs found as much of
your string as it could.  Thus, if you search for `FOOT', and there is
no `FOOT', you might see the cursor after the `FOO' in `FOOL'.  At this
point there are several things you can do.  If your string was
mistyped, you can rub some of it out and correct it.  If you like the
place you have found, you can type <RET> or some other Emacs command to
remain there.  Or you can type `C-g', which removes from the search
string the characters that could not be found (the `T' in `FOOT'),
leaving those that were found (the `FOO' in `FOOT').  A second `C-g' at
that point cancels the search entirely, returning point to where it was
when the search started.

   An upper-case letter in the search string makes the search
case-sensitive.  If you delete the upper-case character from the search
string, it ceases to have this effect.  *Note Search Case::.

   To search for a newline, type `C-j'.  To search for another control
character, such as control-S or carriage return, you must quote it by
typing `C-q' first.  This function of `C-q' is analogous to its use for
insertion (*note Inserting Text::): it causes the following character
to be treated the way any "ordinary" character is treated in the same
context.  You can also specify a character by its octal code: enter
`C-q' followed by a sequence of octal digits.

   To search for non-ASCII characters, you must use an input method
(*note Input Methods::).  If an input method is enabled in the current
buffer when you start the search, you can use it while you type the
search string also.  Emacs indicates that by including the input method
mnemonic in its prompt, like this:

     I-search [IM]:

where IM is the mnemonic of the active input method.  You can toggle
(enable or disable) the input method while you type the search string
with `C-\' (`isearch-toggle-input-method').  You can turn on a certain
(non-default) input method with `C-^'
(`isearch-toggle-specified-input-method'), which prompts for the name
of the input method.  The input method you enable during incremental
search remains enabled in the current buffer afterwards.

   If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating a
failing reverse search with `C-r' starts again from the end.  This is
called "wrapping around", and `Wrapped' appears in the search prompt
once this has happened.  If you keep on going past the original
starting point of the search, it changes to `Overwrapped', which means
that you are revisiting matches that you have already seen.

   The `C-g' "quit" character does special things during searches; just
what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, `C-g' cancels the
entire search.  The cursor moves back to where you started the search.
If `C-g' is typed when there are characters in the search string that
have not been found--because Emacs is still searching for them, or
because it has failed to find them--then the search string characters
which have not been found are discarded from the search string.  With
them gone, the search is now successful and waiting for more input, so
a second `C-g' will cancel the entire search.

   You can change to searching backwards with `C-r'.  If a search fails
because the place you started was too late in the file, you should do
this.  Repeated `C-r' keeps looking for more occurrences backwards.  A
`C-s' starts going forwards again.  `C-r' in a search can be canceled
with <DEL>.

   If you know initially that you want to search backwards, you can use
`C-r' instead of `C-s' to start the search, because `C-r' as a key runs
a command (`isearch-backward') to search backward.  A backward search
finds matches that are entirely before the starting point, just as a
forward search finds matches that begin after it.

   The characters `C-y' and `C-w' can be used in incremental search to
grab text from the buffer into the search string.  This makes it
convenient to search for another occurrence of text at point.  `C-w'
copies the word after point as part of the search string, advancing
point over that word.  Another `C-s' to repeat the search will then
search for a string including that word.  `C-y' is similar to `C-w' but
copies all the rest of the current line into the search string.  Both
`C-y' and `C-w' convert the text they copy to lower case if the search
is currently not case-sensitive; this is so the search remains
case-insensitive.

   The character `M-y' copies text from the kill ring into the search
string.  It uses the same text that `C-y' as a command would yank.
`Mouse-2' in the echo area does the same.  *Note Yanking::.

   When you exit the incremental search, it sets the mark to where point
_was_, before the search.  That is convenient for moving back there.
In Transient Mark mode, incremental search sets the mark without
activating it, and does so only if the mark is not already active.

   When you pause for a little while during incremental search, it
highlights all other possible matches for the search string.  This
makes it easier to anticipate where you can get to by typing `C-s' or
`C-r' to repeat the search.  The short delay before highlighting other
matches helps indicate which match is the current one.  If you don't
like this feature, you can turn it off by setting
`isearch-lazy-highlight' to `nil'.

   You can control how this highlighting looks by customizing the faces
`isearch' (used for the current match) and
`isearch-lazy-highlight-face' (for all the other matches).

   To customize the special characters that incremental search
understands, alter their bindings in the keymap `isearch-mode-map'.
For a list of bindings, look at the documentation of `isearch-mode' with
`C-h f isearch-mode <RET>'.

Slow Terminal Incremental Search
--------------------------------

   Incremental search on a slow terminal uses a modified style of
display that is designed to take less time.  Instead of redisplaying
the buffer at each place the search gets to, it creates a new
single-line window and uses that to display the line that the search
has found.  The single-line window comes into play as soon as point
moves outside of the text that is already on the screen.

   When you terminate the search, the single-line window is removed.
Emacs then redisplays the window in which the search was done, to show
its new position of point.

   The slow terminal style of display is used when the terminal baud
rate is less than or equal to the value of the variable
`search-slow-speed', initially 1200.  See `baud-rate' in *Note Display
Custom::.

   The number of lines to use in slow terminal search display is
controlled by the variable `search-slow-window-lines'.  Its normal
value is 1.


File: emacs,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

Nonincremental Search
=====================

   Emacs also has conventional nonincremental search commands, which
require you to type the entire search string before searching begins.

`C-s <RET> STRING <RET>'
     Search for STRING.

`C-r <RET> STRING <RET>'
     Search backward for STRING.

   To do a nonincremental search, first type `C-s <RET>'.  This enters
the minibuffer to read the search string; terminate the string with
<RET>, and then the search takes place.  If the string is not found,
the search command signals an error.

   When you type `C-s <RET>', the `C-s' invokes incremental search as
usual.  That command is specially programmed to invoke nonincremental
search, `search-forward', if the string you specify is empty.  (Such an
empty argument would otherwise be useless.)  But it does not call
`search-forward' right away.  First it checks the next input character
to see if is `C-w', which specifies a word search.  *Note Word Search::.
`C-r <RET>' does likewise, for a reverse incremental search.

   Forward and backward nonincremental searches are implemented by the
commands `search-forward' and `search-backward'.  These commands may be
bound to keys in the usual manner.  The feature that you can get to
them via the incremental search commands exists for historical reasons,
and to avoid the need to find key sequences for them.


File: emacs,  Node: Word Search,  Next: Regexp Search,  Prev: Nonincremental Search,  Up: Search

Word Search
===========

   Word search searches for a sequence of words without regard to how
the words are separated.  More precisely, you type a string of many
words, using single spaces to separate them, and the string can be
found even if there are multiple spaces, newlines, or other punctuation
characters between these words.

   Word search is useful for editing a printed document made with a text
formatter.  If you edit while looking at the printed, formatted version,
you can't tell where the line breaks are in the source file.  With word
search, you can search without having to know them.

`C-s <RET> C-w WORDS <RET>'
     Search for WORDS, ignoring details of punctuation.

`C-r <RET> C-w WORDS <RET>'
     Search backward for WORDS, ignoring details of punctuation.

   Word search is a special case of nonincremental search and is invoked
with `C-s <RET> C-w'.  This is followed by the search string, which
must always be terminated with <RET>.  Being nonincremental, this
search does not start until the argument is terminated.  It works by
constructing a regular expression and searching for that; see *Note
Regexp Search::.

   Use `C-r <RET> C-w' to do backward word search.

   Forward and backward word searches are implemented by the commands
`word-search-forward' and `word-search-backward'.  These commands may
be bound to keys in the usual manner.  They are available via the
incremental search commands both for historical reasons and to avoid
the need to find suitable key sequences for them.


File: emacs,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

Regular Expression Search
=========================

   A "regular expression" ("regexp", for short) is a pattern that
denotes a class of alternative strings to match, possibly infinitely
many.  GNU Emacs provides both incremental and nonincremental ways to
search for a match for a regexp.

   Incremental search for a regexp is done by typing `C-M-s'
(`isearch-forward-regexp'), or by invoking `C-s' with a prefix argument
(whose value does not matter).  This command reads a search string
incrementally just like `C-s', but it treats the search string as a
regexp rather than looking for an exact match against the text in the
buffer.  Each time you add text to the search string, you make the
regexp longer, and the new regexp is searched for.  To search backward
for a regexp, use `C-M-r' (`isearch-backward-regexp'), or `C-r' with a
prefix argument.

   All of the control characters that do special things within an
ordinary incremental search have the same function in incremental regexp
search.  Typing `C-s' or `C-r' immediately after starting the search
retrieves the last incremental search regexp used; that is to say,
incremental regexp and non-regexp searches have independent defaults.
They also have separate search rings that you can access with `M-p' and
`M-n'.

   If you type <SPC> in incremental regexp search, it matches any
sequence of whitespace characters, including newlines.  If you want to
match just a space, type `C-q <SPC>'.

   Note that adding characters to the regexp in an incremental regexp
search can make the cursor move back and start again.  For example, if
you have searched for `foo' and you add `\|bar', the cursor backs up in
case the first `bar' precedes the first `foo'.

   Nonincremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke these
with `M-x', or bind them to keys, or invoke them by way of incremental
regexp search with `C-M-s <RET>' and `C-M-r <RET>'.

   If you use the incremental regexp search commands with a prefix
argument, they perform ordinary string search, like `isearch-forward'
and `isearch-backward'.  *Note Incremental Search::.


File: emacs,  Node: Regexps,  Next: Search Case,  Prev: Regexp Search,  Up: Search

Syntax of Regular Expressions
=============================

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that same character and
nothing else.  The special characters are `$', `^', `.', `*', `+', `?',
`[', `]' and `\'.  Any other character appearing in a regular
expression is ordinary, unless a `\' precedes it.  (When you use regular
expressions in a Lisp program, each `\' must be doubled, see the
example near the end of this section.)

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does _not_ match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.  (When case distinctions
are being ignored, these regexps also match `F' and `O', but we
consider this a generalization of "the same string," rather than an
exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something nontrivial, you need to
use one of the special characters.  Here is a list of them.

`. (Period)'
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b', which matches any three-character string that begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a postfix operator that means
     to match the preceding regular expression repetitively as many
     times as possible.  Thus, `o*' matches any number of `o's
     (including no `o's).

     `*' always applies to the _smallest_ possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.  It matches `f', `fo', `foo', and so on.

     The matcher processes a `*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the `*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     in matching `ca*ar' against the string `caaar', the `a*' first
     tries to match all three `a's; but the rest of the pattern is `ar'
     and there is only `r' left to match, so this try fails.  The next
     alternative is for `a*' to match only two `a's.  With this choice,
     the rest of the regexp matches successfully.

`+'
     is a postfix operator, similar to `*' except that it must match
     the preceding expression at least once.  So, for example, `ca+r'
     matches the strings `car' and `caaaar' but not the string `cr',
     whereas `ca*r' matches all three strings.

`?'
     is a postfix operator, similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' matches `car' or `cr'; nothing else.

`*?, +?, ??'
     are non-greedy variants of the operators above.  The normal
     operators `*', `+', `?' are "greedy" in that they match as much as
     they can, as long as the overall regexp can still match.  With a
     following `?', they are non-greedy: they will match as little as
     possible.

     Thus, both `ab*' and `ab*?' can match the string `a' and the
     string `abbbb'; but if you try to match them both against the text
     `abbb', `ab*' will match it all (the longest valid match), while
     `ab*?'  will match just `a' (the shortest valid match).

`\{N\}'
     is a postfix operator that specifies repetition N times--that is,
     the preceding regular expression must match exactly N times in a
     row.  For example, `x\{4\}' matches the string `xxxx' and nothing
     else.

`\{N,M\}'
     is a postfix operator that specifies repetition between N and M
     times--that is, the preceding regular expression must match at
     least N times, but no more than M times.  If M is omitted, then
     there is no upper limit, but the preceding regular expression must
     match at least N times.
     `\{0,1\}' is equivalent to `?'.
     `\{0,\}' is equivalent to `*'.
     `\{1,\}' is equivalent to `+'.

`[ ... ]'
     is a "character set", which begins with `[' and is terminated by
     `]'.  In the simplest case, the characters between the two
     brackets are what this set can match.

     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     You can also include character ranges in a character set, by
     writing the starting and ending characters with a `-' between
     them.  Thus, `[a-z]' matches any lower-case ASCII letter.  Ranges
     may be intermixed freely with individual characters, as in
     `[a-z$%.]', which matches any lower-case ASCII letter or `$', `%'
     or period.

     Note that the usual regexp special characters are not special
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `-' as the first or last character of the set, or put
     it after a range.  Thus, `[]-]' matches both `]' and `-'.

     To include `^' in a set, put it anywhere but at the beginning of
     the set.  (At the beginning, it complements the set--see below.)

     When you use a range in case-insensitive search, you should write
     both ends of the range in upper case, or both in lower case, or
     both should be non-letters.  The behavior of a mixed-case range
     such as `A-z' is somewhat ill-defined, and it may change in future
     Emacs versions.

`[^ ... ]'
     `[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters _except_ ASCII letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (in other words, `-' and `]' are not special there).

     A complemented character set can match a newline, unless newline is
     mentioned as one of the characters not to match.  This is in
     contrast to the handling of regexps in programs such as `grep'.

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' that occurs
     at the beginning of a line.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `x+$' matches a string of one `x' or more at the end of a line.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression that matches only `$', and `\[' is a regular expression
     that matches only `[', and so on.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, `*foo' treats `*' as ordinary since there is no
preceding expression on which the `*' can act.  It is poor practice to
depend on this behavior; it is better to quote the special character
anyway, regardless of where it appears.

   For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with `\' that have special meanings.  The second
character in the sequence is always an ordinary character when used on
its own.  Here is a table of `\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches some text if
     either A matches it or B matches it.  It works by trying to match
     A, and if that fails, by trying to match B.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix operators
          `*', `+' and `?' to operate on.  Thus, `ba\(na\)*' matches
          `bananana', etc., with any (zero or more) number of `na'
          strings.

       3. To record a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that is assigned
     as a second meaning to the same `\( ... \)' construct.  In practice
     there is usually no conflict between the two meanings; when there
     is a conflict, you can use a "shy" group.

`\(?: ... \)'
     specifies a "shy" group that does not record the matched substring;
     you can't refer back to it with `\D'.  This is useful in
     mechanically combining regular expressions, so that you can add
     groups for syntactic purposes without interfering with the
     numbering of the groups that were written by the user.

`\D'
     matches the same text that matched the Dth occurrence of a `\( ...
     \)' construct.

     After the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use `\' followed by the
     digit D to mean "match the same text matched the Dth time by the
     `\( ... \)' construct."

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in the order that the open-parentheses appear in the regular
     expression.  So you can use `\1' through `\9' to refer to the text
     matched by the corresponding `\( ... \)' constructs.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

     If a particular `\( ... \)' construct matches more than once
     (which can easily happen if it is followed by `*'), only the last
     match is recorded.

`\`'
     matches the empty string, but only at the beginning of the buffer
     or string being matched against.

`\''
     matches the empty string, but only at the end of the buffer or
     string being matched against.

`\='
     matches the empty string, but only at point.

`\b'
     matches the empty string, but only at the beginning or end of a
     word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

     `\b' matches at the beginning or end of the buffer regardless of
     what text appears next to it.

`\B'
     matches the empty string, but _not_ at the beginning or end of a
     word.

`\<'
     matches the empty string, but only at the beginning of a word.
     `\<' matches at the beginning of the buffer only if a
     word-constituent character follows.

`\>'
     matches the empty string, but only at the end of a word.  `\>'
     matches at the end of the buffer only if the contents end with a
     word-constituent character.

`\w'
     matches any word-constituent character.  The syntax table
     determines which characters these are.  *Note Syntax::.

`\W'
     matches any character that is not a word-constituent.

`\sC'
     matches any character whose syntax is C.  Here C is a character
     that designates a particular syntax class: thus, `w' for word
     constituent, `-' or ` ' for whitespace, `.' for ordinary
     punctuation, etc.  *Note Syntax::.

`\SC'
     matches any character whose syntax is not C.

`\cC'
     matches any character that belongs to the category C.  For
     example, `\cc' matches Chinese characters, `\cg' matches Greek
     characters, etc.  For the description of the known categories,
     type `M-x describe-categories <RET>'.

`\CC'
     matches any character that does _not_ belong to category C.

   The constructs that pertain to words and syntax are controlled by the
setting of the syntax table (*note Syntax::).

   Here is a complicated regexp, stored in `sentence-end' and used by
Emacs to recognize the end of a sentence together with any whitespace
that follows.  We show its Lisp syntax to distinguish the spaces from
the tab characters.  In Lisp syntax, the string constant begins and
ends with a double-quote.  `\"' stands for a double-quote as part of
the regexp, `\\' for a backslash as part of the regexp, `\t' for a tab,
and `\n' for a newline.

     "[.?!][]\"')]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

This contains four parts in succession: a character set matching
period, `?', or `!'; a character set matching close-brackets, quotes,
or parentheses, repeated zero or more times; a set of alternatives
within backslash-parentheses that matches either end-of-line, a space
at the end of a line, a tab, or two spaces; and a character set
matching whitespace characters, repeated any number of times.

   To enter the same regexp interactively, you would type <TAB> to
enter a tab, and `C-j' to enter a newline.  (When typed interactively,
`C-j' should be preceded by a `C-q', to prevent Emacs from running the
command bound to a newline.)  You would also type single backslashes as
themselves, instead of doubling them for Lisp syntax.


File: emacs,  Node: Search Case,  Next: Replace,  Prev: Regexps,  Up: Search

Searching and Case
==================

   Incremental searches in Emacs normally ignore the case of the text
they are searching through, if you specify the text in lower case.
Thus, if you specify searching for `foo', then `Foo' and `foo' are also
considered a match.  Regexps, and in particular character sets, are
included: `[ab]' would match `a' or `A' or `b' or `B'.

   An upper-case letter anywhere in the incremental search string makes
the search case-sensitive.  Thus, searching for `Foo' does not find
`foo' or `FOO'.  This applies to regular expression search as well as
to string search.  The effect ceases if you delete the upper-case
letter from the search string.

   Typing `M-c' within an incremental search toggles the case
sensitivity of that search.  The effect does not extend beyond the
current incremental search to the next one, but it does override the
effect of including an upper-case letter in the current search.

   If you set the variable `case-fold-search' to `nil', then all
letters must match exactly, including case.  This is a per-buffer
variable; altering the variable affects only the current buffer, but
there is a default value which you can change as well.  *Note Locals::.
This variable applies to nonincremental searches also, including those
performed by the replace commands (*note Replace::) and the minibuffer
history matching commands (*note Minibuffer History::).


File: emacs,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

Replacement Commands
====================

   Global search-and-replace operations are not needed often in Emacs,
but they are available.  In addition to the simple `M-x replace-string'
command which is like that found in most editors, there is a `M-x
query-replace' command which finds each occurrence of the pattern and
asks you whether to replace it.

   The replace commands normally operate on the text from point to the
end of the buffer; however, in Transient Mark mode (*note Transient
Mark::), when the mark is active, they operate on the region.  The
replace commands all replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs' (*note Expanding
Abbrevs::).

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: emacs,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

Unconditional Replacement
-------------------------

`M-x replace-string <RET> STRING <RET> NEWSTRING <RET>'
     Replace every occurrence of STRING with NEWSTRING.

`M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace every match for REGEXP with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement happens only in the text after point, so if you want to
cover the whole buffer you must go to the beginning first.  All
occurrences up to the end of the buffer are replaced; to limit
replacement to part of the buffer, narrow to that part of the buffer
before doing the replacement (*note Narrowing::).  In Transient Mark
mode, when the region is active, replacement is limited to the region
(*note Transient Mark::).

   When `replace-string' exits, it leaves point at the last occurrence
replaced.  It sets the mark to the prior position of point (where the
`replace-string' command was issued); use `C-u C-<SPC>' to move back
there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.  The argument's value doesn't matter.


File: emacs,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

Regexp Replacement
------------------

   The `M-x replace-string' command replaces exact matches for a single
string.  The similar command `M-x replace-regexp' replaces any match
for a specified pattern.

   In `replace-regexp', the NEWSTRING need not be constant: it can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire match being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the Dth
parenthesized grouping in REGEXP.  To include a `\' in the text to
replace with, you must enter `\\'.  For example,

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

replaces (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

performs the inverse transformation.


File: emacs,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

Replace Commands and Case
-------------------------

   If the first argument of a replace command is all lower case, the
command ignores case while searching for occurrences to
replace--provided `case-fold-search' is non-`nil'.  If
`case-fold-search' is set to `nil', case is always significant in all
searches.

   In addition, when the NEWSTRING argument is all or partly lower
case, replacement commands try to preserve the case pattern of each
occurrence.  Thus, the command

     M-x replace-string <RET> foo <RET> bar <RET>

replaces a lower case `foo' with a lower case `bar', an all-caps `FOO'
with `BAR', and a capitalized `Foo' with `Bar'.  (These three
alternatives--lower case, all caps, and capitalized, are the only ones
that `replace-string' can distinguish.)

   If upper-case letters are used in the replacement string, they remain
upper case every time that text is inserted.  If upper-case letters are
used in the first argument, the second argument is always substituted
exactly as given, with no case conversion.  Likewise, if either
`case-replace' or `case-fold-search' is set to `nil', replacement is
done without case conversion.


File: emacs,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

Query Replace
-------------

`M-% STRING <RET> NEWSTRING <RET>'
`M-x query-replace <RET> STRING <RET> NEWSTRING <RET>'
     Replace some occurrences of STRING with NEWSTRING.

`C-M-% REGEXP <RET> NEWSTRING <RET>'
`M-x query-replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, then you cannot use an ordinary
`replace-string'.  Instead, use `M-%' (`query-replace').  This command
finds occurrences of `foo' one by one, displays each occurrence and
asks you whether to replace it.  Aside from querying, `query-replace'
works just like `replace-string'.  It preserves case, like
`replace-string', provided `case-replace' is non-`nil', as it normally
is.  A numeric argument means consider only occurrences that are
bounded by word-delimiter characters.

   `C-M-%' performs regexp search and replace (`query-replace-regexp').

   The characters you can type when you are shown a match for the string
or regexp are:

`<SPC>'
     to replace the occurrence with NEWSTRING.

`<DEL>'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character to say what to do next.  Since
     the replacement has already been made, <DEL> and <SPC> are
     equivalent in this situation; both move to the next occurrence.

     You can type `C-r' at this point (see below) to alter the replaced
     text.  You can also type `C-x u' to undo the replacement; this
     exits the `query-replace', so if you want to do further
     replacement you must use `C-x <ESC> <ESC> <RET>' to restart (*note
     Repetition::).

`<RET>'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit without searching for more
     occurrences.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the position of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake.
     This works by popping the mark ring.  Only one `^' in a row is
     meaningful, because only one previous replacement position is kept
     during `query-replace'.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' to proceed
     to the next occurrence.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in `C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with `C-M-c' to proceed to the next occurrence.

`e'
     to edit the replacement string in the minibuffer.  When you exit
     the minibuffer by typing <RET>, the minibuffer contents replace the
     current occurrence of the pattern.  They also become the new
     replacement string for any further occurrences.

`C-l'
     to redisplay the screen.  Then you must type another character to
     specify what to do with this occurrence.

`C-h'
     to display a message summarizing these options.  Then you must type
     another character to specify what to do with this occurrence.

   Some other characters are aliases for the ones listed above: `y',
`n' and `q' are equivalent to <SPC>, <DEL> and <RET>.

   Aside from this, any other character exits the `query-replace', and
is then reread as part of a key sequence.  Thus, if you type `C-k', it
exits the `query-replace' and then kills to end of line.

   To restart a `query-replace' once it is exited, use `C-x <ESC>
<ESC>', which repeats the `query-replace' because it used the
minibuffer to read its arguments.  *Note C-x ESC ESC: Repetition.

   See also *Note Transforming File Names::, for Dired commands to
rename, copy, or link files by replacing regexp matches in file names.


File: emacs,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

Other Search-and-Loop Commands
==============================

   Here are some other commands that find matches for a regular
expression.  They all ignore case in matching, if the pattern contains
no upper-case letters and `case-fold-search' is non-`nil'.  Aside from
`occur', all operate on the text from point to the end of the buffer,
or on the active region in Transient Mark mode.

`M-x occur <RET> REGEXP <RET>'
     Display a list showing each line in the buffer that contains a
     match for REGEXP.  To limit the search to part of the buffer,
     narrow to that part (*note Narrowing::).  A numeric argument N
     specifies that N lines of context are to be displayed before and
     after each matching line.

     The buffer `*Occur*' containing the output serves as a menu for
     finding the occurrences in their original context.  Click `Mouse-2'
     on an occurrence listed in `*Occur*', or position point there and
     type <RET>; this switches to the buffer that was searched and
     moves point to the original of the chosen occurrence.

`M-x list-matching-lines'
     Synonym for `M-x occur'.

`M-x how-many <RET> REGEXP <RET>'
     Print the number of matches for REGEXP that exist in the buffer
     after point.  In Transient Mark mode, if the region is active, the
     command operates on the region instead.

`M-x flush-lines <RET> REGEXP <RET>'
     Delete each line that contains a match for REGEXP, operating on
     the text after point.  In Transient Mark mode, if the region is
     active, the command operates on the region instead.

`M-x keep-lines <RET> REGEXP <RET>'
     Delete each line that _does not_ contain a match for REGEXP,
     operating on the text after point.  In Transient Mark mode, if the
     region is active, the command operates on the region instead.

   You can also search multiple files under control of a tags table
(*note Tags Search::) or through Dired `A' command (*note Operating on
Files::), or ask the `grep' program to do it (*note Grep Searching::).


File: emacs,  Node: Fixit,  Next: Files,  Prev: Search,  Up: Top

Commands for Fixing Typos
*************************

   In this chapter we describe the commands that are especially useful
for the times when you catch a mistake in your text just after you have
made it, or change your mind while composing text on the fly.

   The most fundamental command for correcting erroneous editing is the
undo command, `C-x u' or `C-_'.  This command undoes a single command
(usually), a part of a command (in the case of `query-replace'), or
several consecutive self-inserting characters.  Consecutive repetitions
of `C-_' or `C-x u' undo earlier and earlier changes, back to the limit
of the undo information available.  *Note Undo::, for more information.

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: emacs,  Node: Kill Errors,  Next: Transpose,  Up: Fixit

Killing Your Mistakes
=====================

`<DEL>'
     Delete last character (`delete-backward-char').

`M-<DEL>'
     Kill last word (`backward-kill-word').

`C-x <DEL>'
     Kill to beginning of sentence (`backward-kill-sentence').

   The <DEL> character (`delete-backward-char') is the most important
correction command.  It deletes the character before point.  When <DEL>
follows a self-inserting character command, you can think of it as
canceling that command.  However, avoid the mistake of thinking of
<DEL> as a general way to cancel a command!

   When your mistake is longer than a couple of characters, it might be
more convenient to use `M-<DEL>' or `C-x <DEL>'.  `M-<DEL>' kills back
to the start of the last word, and `C-x <DEL>' kills back to the start
of the last sentence.  `C-x <DEL>' is particularly useful when you
change your mind about the phrasing of the text you are writing.
`M-<DEL>' and `C-x <DEL>' save the killed text for `C-y' and `M-y' to
retrieve.  *Note Yanking::.

   `M-<DEL>' is often useful even when you have typed only a few
characters wrong, if you know you are confused in your typing and aren't
sure exactly what you typed.  At such a time, you cannot correct with
<DEL> except by looking at the screen to see what you did.  Often it
requires less thought to kill the whole word and start again.


File: emacs,  Node: Transpose,  Next: Fixing Case,  Prev: Kill Errors,  Up: Fixit

Transposing Text
================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two characters can be fixed, when
they are adjacent, with the `C-t' command (`transpose-chars').
Normally, `C-t' transposes the two characters on either side of point.
When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, `C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a `C-t'.  If
you don't catch it so fast, you must move the cursor back between the
two transposed characters before you type `C-t'.  If you transposed a
space with the last character of the word before it, the word motion
commands are a good way of getting there.  Otherwise, a reverse search
(`C-r') is often the best way.  *Note Search::.

   `M-t' transposes the word before point with the word after point
(`transpose-words').  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, `FOO, BAR'
transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing two
expressions (*note Expressions::), and `C-x C-t' (`transpose-lines')
exchanges lines.  They work like `M-t' except as regards what units of
text they transpose.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, expression,
line) before or containing point across several other characters (words,
expressions, lines).  For example, `C-u 3 C-t' moves the character
before point forward across three other characters.  It would change
`f-!-oobar' into `oobf-!-ar'.  This is equivalent to repeating `C-t'
three times.  `C-u - 4 M-t' moves the word before point backward across
four words.  `C-u - C-M-t' would cancel the effect of plain `C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (word, expression, line) ending after point
with the one ending after the mark.


File: emacs,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

Case Conversion
===============

`M-- M-l'
     Convert last word to lower case.  Note `Meta--' is Meta-minus.

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands `M-l', `M-u' and `M-c' have a
special feature when used with a negative argument: they do not move the
cursor.  As soon as you see you have mistyped the last word, you can
simply case-convert it and go on typing.  *Note Case::.

