This is ../info/emacs, produced by makeinfo version 4.3 from emacs.texi.

   This is the Fourteenth edition of the `GNU Emacs Manual', updated
for Emacs version 21.3.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C)
1985,1986,1987,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002
Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto", "Distribution" and "GNU
GENERAL PUBLIC LICENSE", with the Front-Cover texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: emacs,  Node: Summary of Gnus,  Prev: Gnus Startup,  Up: Gnus

Summary of Gnus Commands
------------------------

   Reading news is a two-step process:

  1. Choose a group in the group buffer.

  2. Select articles from the summary buffer.  Each article selected is
     displayed in the article buffer in a large window, below the
     summary buffer in its small window.

   Each Gnus buffer has its own special commands; however, the meanings
of any given key in the various Gnus buffers are usually analogous, even
if not identical.  Here are commands for the group and summary buffers:

`q'
     In the group buffer, update your `.newsrc' initialization file and
     quit Gnus.

     In the summary buffer, exit the current group and return to the
     group buffer.  Thus, typing `q' twice quits Gnus.

`L'
     In the group buffer, list all the groups available on your news
     server (except those you have killed).  This may be a long list!

`l'
     In the group buffer, list only the groups to which you subscribe
     and which contain unread articles.

`u'
     In the group buffer, unsubscribe from (or subscribe to) the group
     listed in the line that point is on.  When you quit Gnus by typing
     `q', Gnus lists in your `.newsrc' file which groups you have
     subscribed to.  The next time you start Gnus, you won't see this
     group, because Gnus normally displays only subscribed-to groups.

`C-k'
     In the group buffer, "kill" the current line's group--don't even
     list it in `.newsrc' from now on.  This affects future Gnus
     sessions as well as the present session.

     When you quit Gnus by typing `q', Gnus writes information in the
     file `.newsrc' describing all newsgroups except those you have
     "killed."

`<SPC>'
     In the group buffer, select the group on the line under the cursor
     and display the first unread article in that group.

     In the summary buffer,

        * Select the article on the line under the cursor if none is
          selected.

        * Scroll the text of the selected article (if there is one).

        * Select the next unread article if at the end of the current
          article.

     Thus, you can move through all the articles by repeatedly typing
     <SPC>.

`<DEL>'
     In the group buffer, move point to the previous group containing
     unread articles.

     In the summary buffer, scroll the text of the article backwards.

`n'
     Move point to the next unread group, or select the next unread
     article.

`p'
     Move point to the previous unread group, or select the previous
     unread article.

`C-n'
`C-p'
     Move point to the next or previous item, even if it is marked as
     read.  This does not select the article or group on that line.

`s'
     In the summary buffer, do an incremental search of the current
     text in the article buffer, just as if you switched to the article
     buffer and typed `C-s'.

`M-s REGEXP <RET>'
     In the summary buffer, search forward for articles containing a
     match for REGEXP.


File: emacs,  Node: Shell,  Next: Emacs Server,  Prev: Gnus,  Up: Top

Running Shell Commands from Emacs
=================================

   Emacs has commands for passing single command lines to inferior shell
processes; it can also run a shell interactively with input and output
to an Emacs buffer named `*shell*' or run a shell inside a terminal
emulator window.

   There is a shell implemented entirely in Emacs, documented in a
separate manual.  *Note Eshell: (eshell)Top.

`M-! CMD <RET>'
     Run the shell command line CMD and display the output
     (`shell-command').

`M-| CMD <RET>'
     Run the shell command line CMD with region contents as input;
     optionally replace the region with the output
     (`shell-command-on-region').

`M-x shell'
     Run a subshell with input and output through an Emacs buffer.  You
     can then give commands interactively.

`M-x term'
     Run a subshell with input and output through an Emacs buffer.  You
     can then give commands interactively.  Full terminal emulation is
     available.

`M-x eshell'
     Start the Emacs shell.

* Menu:

* Single Shell::           How to run one shell command and return.
* Interactive Shell::      Permanent shell taking input via Emacs.
* Shell Mode::             Special Emacs commands used with permanent shell.
* History: Shell History.  Repeating previous commands in a shell buffer.
* Directory Tracking::     Keeping track when the subshell changes directory.
* Options: Shell Options.  Options for customizing Shell mode.
* Terminal emulator::      An Emacs window as a terminal emulator.
* Term Mode::              Special Emacs commands used in Term mode.
* Paging in Term::         Paging in the terminal emulator.
* Remote Host::            Connecting to another computer.


File: emacs,  Node: Single Shell,  Next: Interactive Shell,  Up: Shell

Single Shell Commands
---------------------

   `M-!' (`shell-command') reads a line of text using the minibuffer
and executes it as a shell command in a subshell made just for that
command.  Standard input for the command comes from the null device.
If the shell command produces any output, the output appears either in
the echo area (if it is short), or in an Emacs buffer named `*Shell
Command Output*', which is displayed in another window but not selected
(if the output is long).

   For instance, one way to decompress a file `foo.gz' from Emacs is to
type `M-! gunzip foo.gz <RET>'.  That shell command normally creates
the file `foo' and produces no terminal output.

   A numeric argument, as in `M-1 M-!', says to insert terminal output
into the current buffer instead of a separate buffer.  It puts point
before the output, and sets the mark after the output.  For instance,
`M-1 M-! gunzip < foo.gz <RET>' would insert the uncompressed
equivalent of `foo.gz' into the current buffer.

   If the shell command line ends in `&', it runs asynchronously.  For
a synchronous shell command, `shell-command' returns the command's exit
status (0 means success), when it is called from a Lisp program.  You
do not get any status information for an asynchronous command, since it
hasn't finished yet.

   `M-|' (`shell-command-on-region') is like `M-!' but passes the
contents of the region as the standard input to the shell command,
instead of no input.  If a numeric argument is used, meaning insert the
output in the current buffer, then the old region is deleted first and
the output replaces it as the contents of the region.  It returns the
command's exit status when it is called from a Lisp program.

   One use for `M-|' is to run `uudecode'.  For instance, if the buffer
contains uuencoded text, type `C-x h M-| uudecode <RET>' to feed the
entire buffer contents to the `uudecode' program.  That program will
ignore everything except the encoded text, and will store the decoded
output into the file whose name is specified in the encoded text.

   Both `M-!' and `M-|' use `shell-file-name' to specify the shell to
use.  This variable is initialized based on your `SHELL' environment
variable when Emacs is started.  If the file name does not specify a
directory, the directories in the list `exec-path' are searched; this
list is initialized based on the environment variable `PATH' when Emacs
is started.  Your `.emacs' file can override either or both of these
default initializations.

   Both `M-!' and `M-|' wait for the shell command to complete.  To
stop waiting, type `C-g' to quit; that terminates the shell command
with the signal `SIGINT'--the same signal that `C-c' normally generates
in the shell.  Emacs waits until the command actually terminates.  If
the shell command doesn't stop (because it ignores the `SIGINT'
signal), type `C-g' again; this sends the command a `SIGKILL' signal
which is impossible to ignore.

   To specify a coding system for `M-!' or `M-|', use the command `C-x
<RET> c' immediately beforehand.  *Note Specify Coding::.

   Error output from the command is normally intermixed with the regular
output.  If you set the variable `shell-command-default-error-buffer'
to a string, which is a buffer name, error output is inserted before
point in the buffer of that name.


File: emacs,  Node: Interactive Shell,  Next: Shell Mode,  Prev: Single Shell,  Up: Shell

Interactive Inferior Shell
--------------------------

   To run a subshell interactively, putting its typescript in an Emacs
buffer, use `M-x shell'.  This creates (or reuses) a buffer named
`*shell*' and runs a subshell with input coming from and output going
to that buffer.  That is to say, any "terminal output" from the subshell
goes into the buffer, advancing point, and any "terminal input" for the
subshell comes from text in the buffer.  To give input to the subshell,
go to the end of the buffer and type the input, terminated by <RET>.

   Emacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while
it is running a command.  Output from the subshell waits until Emacs
has time to process it; this happens whenever Emacs is waiting for
keyboard input or for time to elapse.

   Input lines, once you submit them, are displayed using the face
`comint-highlight-input', and prompts are displayed using the face
`comint-highlight-prompt'.  This makes it easier to see previous input
lines in the buffer.  *Note Faces::.

   To make multiple subshells, you can invoke `M-x shell' with a prefix
argument (e.g. `C-u M-x shell'), which will read a buffer name and
create (or reuse) a subshell in that buffer.  You can also rename the
`*shell*' buffer using `M-x rename-uniquely', then create a new
`*shell*' buffer using plain `M-x shell'.  All the subshells in
different buffers run independently and in parallel.

   The file name used to load the subshell is the value of the variable
`explicit-shell-file-name', if that is non-`nil'.  Otherwise, the
environment variable `ESHELL' is used, or the environment variable
`SHELL' if there is no `ESHELL'.  If the file name specified is
relative, the directories in the list `exec-path' are searched; this
list is initialized based on the environment variable `PATH' when Emacs
is started.  Your `.emacs' file can override either or both of these
default initializations.

   Emacs sends the new shell the contents of the file
`~/.emacs_SHELLNAME' as input, if it exists, where SHELLNAME is the
name of the file that the shell was loaded from.  For example, if you
use bash, the file sent to it is `~/.emacs_bash'.

   To specify a coding system for the shell, you can use the command
`C-x <RET> c' immediately before `M-x shell'.  You can also specify a
coding system after starting the shell by using `C-x <RET> p' in the
shell buffer.  *Note Specify Coding::.

   Unless the environment variable `EMACS' is already defined, Emacs
defines it in the subshell, with value `t'.  A shell script can check
this variable to determine whether it has been run from an Emacs
subshell.


File: emacs,  Node: Shell Mode,  Next: Shell History,  Prev: Interactive Shell,  Up: Shell

Shell Mode
----------

   Shell buffers use Shell mode, which defines several special keys
attached to the `C-c' prefix.  They are chosen to resemble the usual
editing and job control characters present in shells that are not under
Emacs, except that you must type `C-c' first.  Here is a complete list
of the special key bindings of Shell mode:

`<RET>'
     At end of buffer send line as input; otherwise, copy current line
     to end of buffer and send it (`comint-send-input').  When a line is
     copied, any prompt at the beginning of the line (text output by
     programs preceding your input) is omitted.  (See also the variable
     `comint-use-prompt-regexp-instead-of-fields'.)

`<TAB>'
     Complete the command name or file name before point in the shell
     buffer (`comint-dynamic-complete').  <TAB> also completes history
     references (*note History References::) and environment variable
     names.

     The variable `shell-completion-fignore' specifies a list of file
     name extensions to ignore in Shell mode completion.  The default
     setting is `nil', but some users prefer `("~" "#" "%")' to ignore
     file names ending in `~', `#' or `%'.  Other related Comint modes
     use the variable `comint-completion-fignore' instead.

`M-?'
     Display temporarily a list of the possible completions of the file
     name before point in the shell buffer
     (`comint-dynamic-list-filename-completions').

`C-d'
     Either delete a character or send EOF
     (`comint-delchar-or-maybe-eof').  Typed at the end of the shell
     buffer, `C-d' sends EOF to the subshell.  Typed at any other
     position in the buffer, `C-d' deletes a character as usual.

`C-c C-a'
     Move to the beginning of the line, but after the prompt if any
     (`comint-bol-or-process-mark').  If you repeat this command twice
     in a row, the second time it moves back to the process mark, which
     is the beginning of the input that you have not yet sent to the
     subshell.  (Normally that is the same place--the end of the prompt
     on this line--but after `C-c <SPC>' the process mark may be in a
     previous line.)

`C-c <SPC>'
     Accumulate multiple lines of input, then send them together.  This
     command inserts a newline before point, but does not send the
     preceding text as input to the subshell--at least, not yet.  Both
     lines, the one before this newline and the one after, will be sent
     together (along with the newline that separates them), when you
     type <RET>.

`C-c C-u'
     Kill all text pending at end of buffer to be sent as input
     (`comint-kill-input').

`C-c C-w'
     Kill a word before point (`backward-kill-word').

`C-c C-c'
     Interrupt the shell or its current subjob if any
     (`comint-interrupt-subjob').  This command also kills any shell
     input pending in the shell buffer and not yet sent.

`C-c C-z'
     Stop the shell or its current subjob if any (`comint-stop-subjob').
     This command also kills any shell input pending in the shell
     buffer and not yet sent.

`C-c C-\'
     Send quit signal to the shell or its current subjob if any
     (`comint-quit-subjob').  This command also kills any shell input
     pending in the shell buffer and not yet sent.

`C-c C-o'
     Delete the last batch of output from a shell command
     (`comint-delete-output').  This is useful if a shell command spews
     out lots of output that just gets in the way.  This command used
     to be called `comint-kill-output'.

`C-c C-s'
     Write the last batch of output from a shell command to a file
     (`comint-write-output').  With a prefix argument, the file is
     appended to instead.  Any prompt at the end of the output is not
     written.

`C-c C-r'
`C-M-l'
     Scroll to display the beginning of the last batch of output at the
     top of the window; also move the cursor there
     (`comint-show-output').

`C-c C-e'
     Scroll to put the end of the buffer at the bottom of the window
     (`comint-show-maximum-output').

`C-c C-f'
     Move forward across one shell command, but not beyond the current
     line (`shell-forward-command').  The variable
     `shell-command-regexp' specifies how to recognize the end of a
     command.

`C-c C-b'
     Move backward across one shell command, but not beyond the current
     line (`shell-backward-command').

`C-c C-l'
     Display the buffer's history of shell commands in another window
     (`comint-dynamic-list-input-ring').

`M-x dirs'
     Ask the shell what its current directory is, so that Emacs can
     agree with the shell.

`M-x send-invisible <RET> TEXT <RET>'
     Send TEXT as input to the shell, after reading it without echoing.
     This is useful when a shell command runs a program that asks for
     a password.

     Alternatively, you can arrange for Emacs to notice password prompts
     and turn off echoing for them, as follows:

          (add-hook 'comint-output-filter-functions
                    'comint-watch-for-password-prompt)

`M-x comint-continue-subjob'
     Continue the shell process.  This is useful if you accidentally
     suspend the shell process.(1)

`M-x comint-strip-ctrl-m'
     Discard all control-M characters from the current group of shell
     output.  The most convenient way to use this command is to make it
     run automatically when you get output from the subshell.  To do
     that, evaluate this Lisp expression:

          (add-hook 'comint-output-filter-functions
                    'comint-strip-ctrl-m)

`M-x comint-truncate-buffer'
     This command truncates the shell buffer to a certain maximum
     number of lines, specified by the variable
     `comint-buffer-maximum-size'.  Here's how to do this automatically
     each time you get output from the subshell:

          (add-hook 'comint-output-filter-functions
                    'comint-truncate-buffer)

   Shell mode also customizes the paragraph commands so that only shell
prompts start new paragraphs.  Thus, a paragraph consists of an input
command plus the output that follows it in the buffer.

   Shell mode is a derivative of Comint mode, a general-purpose mode for
communicating with interactive subprocesses.  Most of the features of
Shell mode actually come from Comint mode, as you can see from the
command names listed above.  The special features of Shell mode include
the directory tracking feature, and a few user commands.

   Other Emacs features that use variants of Comint mode include GUD
(*note Debuggers::) and `M-x run-lisp' (*note External Lisp::).

   You can use `M-x comint-run' to execute any program of your choice
in a subprocess using unmodified Comint mode--without the
specializations of Shell mode.

   ---------- Footnotes ----------

   (1) You should not suspend the shell process.  Suspending a subjob
of the shell is a completely different matter--that is normal practice,
but you must use the shell to continue the subjob; this command won't
do it.


File: emacs,  Node: Shell History,  Next: Directory Tracking,  Prev: Shell Mode,  Up: Shell

Shell Command History
---------------------

   Shell buffers support three ways of repeating earlier commands.  You
can use the same keys used in the minibuffer; these work much as they do
in the minibuffer, inserting text from prior commands while point
remains always at the end of the buffer.  You can move through the
buffer to previous inputs in their original place, then resubmit them or
copy them to the end.  Or you can use a `!'-style history reference.

* Menu:

* Ring: Shell Ring.             Fetching commands from the history list.
* Copy: Shell History Copying.  Moving to a command and then copying it.
* History References::          Expanding `!'-style history references.


File: emacs,  Node: Shell Ring,  Next: Shell History Copying,  Up: Shell History

Shell History Ring
..................

`M-p'
     Fetch the next earlier old shell command.

`M-n'
     Fetch the next later old shell command.

`M-r REGEXP <RET>'
`M-s REGEXP <RET>'
     Search backwards or forwards for old shell commands that match
     REGEXP.

`C-c C-x (Shell mode)'
     Fetch the next subsequent command from the history.

   Shell buffers provide a history of previously entered shell
commands.  To reuse shell commands from the history, use the editing
commands `M-p', `M-n', `M-r' and `M-s'.  These work just like the
minibuffer history commands except that they operate on the text at the
end of the shell buffer, where you would normally insert text to send
to the shell.

   `M-p' fetches an earlier shell command to the end of the shell
buffer.  Successive use of `M-p' fetches successively earlier shell
commands, each replacing any text that was already present as potential
shell input.  `M-n' does likewise except that it finds successively
more recent shell commands from the buffer.

   The history search commands `M-r' and `M-s' read a regular
expression and search through the history for a matching command.  Aside
from the choice of which command to fetch, they work just like `M-p'
and `M-n'.  If you enter an empty regexp, these commands reuse the same
regexp used last time.

   When you find the previous input you want, you can resubmit it by
typing <RET>, or you can edit it first and then resubmit it if you wish.

   Often it is useful to reexecute several successive shell commands
that were previously executed in sequence.  To do this, first find and
reexecute the first command of the sequence.  Then type `C-c C-x'; that
will fetch the following command--the one that follows the command you
just repeated.  Then type <RET> to reexecute this command.  You can
reexecute several successive commands by typing `C-c C-x <RET>' over
and over.

   These commands get the text of previous shell commands from a special
history list, not from the shell buffer itself.  Thus, editing the shell
buffer, or even killing large parts of it, does not affect the history
that these commands access.

   Some shells store their command histories in files so that you can
refer to previous commands from previous shell sessions.  Emacs reads
the command history file for your chosen shell, to initialize its own
command history.  The file name is `~/.bash_history' for bash,
`~/.sh_history' for ksh, and `~/.history' for other shells.


File: emacs,  Node: Shell History Copying,  Next: History References,  Prev: Shell Ring,  Up: Shell History

Shell History Copying
.....................

`C-c C-p'
     Move point to the previous prompt (`comint-previous-prompt').

`C-c C-n'
     Move point to the following prompt (`comint-next-prompt').

`C-c <RET>'
     Copy the input command which point is in, inserting the copy at
     the end of the buffer (`comint-copy-old-input').  This is useful
     if you move point back to a previous command.  After you copy the
     command, you can submit the copy as input with <RET>.  If you
     wish, you can edit the copy before resubmitting it.

   Moving to a previous input and then copying it with `C-c <RET>'
produces the same results--the same buffer contents--that you would get
by using `M-p' enough times to fetch that previous input from the
history list.  However, `C-c <RET>' copies the text from the buffer,
which can be different from what is in the history list if you edit the
input text in the buffer after it has been sent.


File: emacs,  Node: History References,  Prev: Shell History Copying,  Up: Shell History

Shell History References
........................

   Various shells including csh and bash support "history references"
that begin with `!' and `^'.  Shell mode recognizes these constructs,
and can perform the history substitution for you.

   If you insert a history reference and type <TAB>, this searches the
input history for a matching command, performs substitution if
necessary, and places the result in the buffer in place of the history
reference.  For example, you can fetch the most recent command
beginning with `mv' with `! m v <TAB>'.  You can edit the command if
you wish, and then resubmit the command to the shell by typing <RET>.

   Shell mode can optionally expand history references in the buffer
when you send them to the shell.  To request this, set the variable
`comint-input-autoexpand' to `input'.  You can make <SPC> perform
history expansion by binding <SPC> to the command `comint-magic-space'.

   Shell mode recognizes history references when they follow a prompt.
Normally, any text output by a program at the beginning of an input
line is considered a prompt.  However, if the variable
`comint-use-prompt-regexp-instead-of-fields' is non-`nil', then Comint
mode uses a regular expression to recognize prompts.  In general, the
variable `comint-prompt-regexp' specifies the regular expression; Shell
mode uses the variable `shell-prompt-pattern' to set up
`comint-prompt-regexp' in the shell buffer.


File: emacs,  Node: Directory Tracking,  Next: Shell Options,  Prev: Shell History,  Up: Shell

Directory Tracking
------------------

   Shell mode keeps track of `cd', `pushd' and `popd' commands given to
the inferior shell, so it can keep the `*shell*' buffer's default
directory the same as the shell's working directory.  It recognizes
these commands syntactically, by examining lines of input that are sent.

   If you use aliases for these commands, you can tell Emacs to
recognize them also.  For example, if the value of the variable
`shell-pushd-regexp' matches the beginning of a shell command line,
that line is regarded as a `pushd' command.  Change this variable when
you add aliases for `pushd'.  Likewise, `shell-popd-regexp' and
`shell-cd-regexp' are used to recognize commands with the meaning of
`popd' and `cd'.  These commands are recognized only at the beginning
of a shell command line.

   If Emacs gets confused about changes in the current directory of the
subshell, use the command `M-x dirs' to ask the shell what its current
directory is.  This command works for shells that support the most
common command syntax; it may not work for unusual shells.

   You can also use `M-x dirtrack-mode' to enable (or disable) an
alternative and more aggressive method of tracking changes in the
current directory.


File: emacs,  Node: Shell Options,  Next: Terminal emulator,  Prev: Directory Tracking,  Up: Shell

Shell Mode Options
------------------

   If the variable `comint-scroll-to-bottom-on-input' is non-`nil',
insertion and yank commands scroll the selected window to the bottom
before inserting.

   If `comint-scroll-show-maximum-output' is non-`nil', then scrolling
due to the arrival of output tries to place the last line of text at
the bottom line of the window, so as to show as much useful text as
possible.  (This mimics the scrolling behavior of many terminals.)  The
default is `nil'.

   By setting `comint-scroll-to-bottom-on-output', you can opt for
having point jump to the end of the buffer whenever output arrives--no
matter where in the buffer point was before.  If the value is `this',
point jumps in the selected window.  If the value is `all', point jumps
in each window that shows the Comint buffer.  If the value is `other',
point jumps in all nonselected windows that show the current buffer.
The default value is `nil', which means point does not jump to the end.

   The variable `comint-input-ignoredups' controls whether successive
identical inputs are stored in the input history.  A non-`nil' value
means to omit an input that is the same as the previous input.  The
default is `nil', which means to store each input even if it is equal
to the previous input.

   Three variables customize file name completion.  The variable
`comint-completion-addsuffix' controls whether completion inserts a
space or a slash to indicate a fully completed file or directory name
(non-`nil' means do insert a space or slash).
`comint-completion-recexact', if non-`nil', directs <TAB> to choose the
shortest possible completion if the usual Emacs completion algorithm
cannot add even a single character.  `comint-completion-autolist', if
non-`nil', says to list all the possible completions whenever
completion is not exact.

   Command completion normally considers only executable files.  If you
set `shell-completion-execonly' to `nil', it considers nonexecutable
files as well.

   You can configure the behavior of `pushd'.  Variables control
whether `pushd' behaves like `cd' if no argument is given
(`shell-pushd-tohome'), pop rather than rotate with a numeric argument
(`shell-pushd-dextract'), and only add directories to the directory
stack if they are not already on it (`shell-pushd-dunique').  The
values you choose should match the underlying shell, of course.


File: emacs,  Node: Terminal emulator,  Next: Term Mode,  Prev: Shell Options,  Up: Shell

Emacs Terminal Emulator
-----------------------

   To run a subshell in a terminal emulator, putting its typescript in
an Emacs buffer, use `M-x term'.  This creates (or reuses) a buffer
named `*terminal*', and runs a subshell with input coming from your
keyboard, and output going to that buffer.

   The terminal emulator uses Term mode, which has two input modes.  In
line mode, Term basically acts like Shell mode; see *Note Shell Mode::.

   In char mode, each character is sent directly to the inferior
subshell, as "terminal input."  Any "echoing" of your input is the
responsibility of the subshell.  The sole exception is the terminal
escape character, which by default is `C-c' (*note Term Mode::).  Any
"terminal output" from the subshell goes into the buffer, advancing
point.

   Some programs (such as Emacs itself) need to control the appearance
on the terminal screen in detail.  They do this by sending special
control codes.  The exact control codes needed vary from terminal to
terminal, but nowadays most terminals and terminal emulators (including
`xterm') understand the ANSI-standard (VT100-style) escape sequences.
Term mode recognizes these escape sequences, and handles each one
appropriately, changing the buffer so that the appearance of the window
matches what it would be on a real terminal.  You can actually run
Emacs inside an Emacs Term window.

   The file name used to load the subshell is determined the same way
as for Shell mode.  To make multiple terminal emulators, rename the
buffer `*terminal*' to something different using `M-x rename-uniquely',
just as with Shell mode.

   Unlike Shell mode, Term mode does not track the current directory by
examining your input.  But some shells can tell Term what the current
directory is.  This is done automatically by `bash' version 1.15 and
later.


File: emacs,  Node: Term Mode,  Next: Paging in Term,  Prev: Terminal emulator,  Up: Shell

Term Mode
---------

   The terminal emulator uses Term mode, which has two input modes.  In
line mode, Term basically acts like Shell mode; see *Note Shell Mode::.
In char mode, each character is sent directly to the inferior subshell,
except for the Term escape character, normally `C-c'.

   To switch between line and char mode, use these commands:

`C-c C-k'
     Switch to line mode.  Do nothing if already in line mode.

`C-c C-j'
     Switch to char mode.  Do nothing if already in char mode.

   The following commands are only available in char mode:

`C-c C-c'
     Send a literal <C-c> to the sub-shell.

`C-c C-x'
     A prefix command to access the global <C-x> commands conveniently.
     For example, `C-c C-x o' invokes the global binding of `C-x o',
     which is normally `other-window'.


File: emacs,  Node: Paging in Term,  Next: Remote Host,  Prev: Term Mode,  Up: Shell

Page-At-A-Time Output
---------------------

   Term mode has a page-at-a-time feature.  When enabled it makes
output pause at the end of each screenful.

`C-c C-q'
     Toggle the page-at-a-time feature.  This command works in both line
     and char modes.  When page-at-a-time is enabled, the mode-line
     displays the word `page'.

   With page-at-a-time enabled, whenever Term receives more than a
screenful of output since your last input, it pauses, displaying
`**MORE**' in the mode-line.  Type <SPC> to display the next screenful
of output.  Type `?' to see your other options.  The interface is
similar to the `more' program.


File: emacs,  Node: Remote Host,  Prev: Paging in Term,  Up: Shell

Remote Host Shell
-----------------

   You can login to a remote computer, using whatever commands you
would from a regular terminal (e.g. using the `telnet' or `rlogin'
commands), from a Term window.

   A program that asks you for a password will normally suppress
echoing of the password, so the password will not show up in the
buffer.  This will happen just as if you were using a real terminal, if
the buffer is in char mode.  If it is in line mode, the password is
temporarily visible, but will be erased when you hit return.  (This
happens automatically; there is no special password processing.)

   When you log in to a different machine, you need to specify the type
of terminal you're using.  Terminal types `ansi' or `vt100' will work
on most systems.


File: emacs,  Node: Emacs Server,  Next: Hardcopy,  Prev: Shell,  Up: Top

Using Emacs as a Server
=======================

   Various programs such as `mail' can invoke your choice of editor to
edit a particular piece of text, such as a message that you are
sending.  By convention, most of these programs use the environment
variable `EDITOR' to specify which editor to run.  If you set `EDITOR'
to `emacs', they invoke Emacs--but in an inconvenient fashion, by
starting a new, separate Emacs process.  This is inconvenient because
it takes time and because the new Emacs process doesn't share the
buffers in any existing Emacs process.

   You can arrange to use your existing Emacs process as the editor for
programs like `mail' by using the Emacs client and Emacs server
programs.  Here is how.

   First, the preparation.  Within Emacs, call the function
`server-start'.  (Your `.emacs' file can do this automatically if you
add the expression `(server-start)' to it.)  Then, outside Emacs, set
the `EDITOR' environment variable to `emacsclient'.  (Note that some
programs use a different environment variable; for example, to make TeX
use `emacsclient', you should set the `TEXEDIT' environment variable to
`emacsclient +%d %s'.)

   Then, whenever any program invokes your specified `EDITOR' program,
the effect is to send a message to your principal Emacs telling it to
visit a file.  (That's what the program `emacsclient' does.)  Emacs
displays the buffer immediately and you can immediately begin editing
it.

   When you've finished editing that buffer, type `C-x #'
(`server-edit').  This saves the file and sends a message back to the
`emacsclient' program telling it to exit.  The programs that use
`EDITOR' wait for the "editor" (actually, `emacsclient') to exit.  `C-x
#' also checks for other pending external requests to edit various
files, and selects the next such file.

   You can switch to a server buffer manually if you wish; you don't
have to arrive at it with `C-x #'.  But `C-x #' is the way to say that
you are finished with one.

   Finishing with a server buffer also kills the buffer, unless it
already existed in the Emacs session before the server asked to create
it.  However, if you set `server-kill-new-buffers' to `nil', then a
different criterion is used: finishing with a server buffer kills it if
the file name matches the regular expression `server-temp-file-regexp'.
This is set up to distinguish certain "temporary" files.

   If you set the variable `server-window' to a window or a frame, `C-x
#' displays the server buffer in that window or in that frame.

   While `mail' or another application is waiting for `emacsclient' to
finish, `emacsclient' does not read terminal input.  So the terminal
that `mail' was using is effectively blocked for the duration.  In
order to edit with your principal Emacs, you need to be able to use it
without using that terminal.  There are three ways to do this:

   * Using a window system, run `mail' and the principal Emacs in two
     separate windows.  While `mail' is waiting for `emacsclient', the
     window where it was running is blocked, but you can use Emacs by
     switching windows.

   * Using virtual terminals, run `mail' in one virtual terminal and
     run Emacs in another.

   * Use Shell mode or Term mode in Emacs to run the other program such
     as `mail'; then, `emacsclient' blocks only the subshell under
     Emacs, and you can still use Emacs to edit the file.

   If you run `emacsclient' with the option `--no-wait', it returns
immediately without waiting for you to "finish" the buffer in Emacs.
Note that server buffers created in this way are not killed
automatically when you finish with them.

* Menu:

* Invoking emacsclient::


File: emacs,  Node: Invoking emacsclient,  Prev: Emacs Server,  Up: Emacs Server

Invoking `emacsclient'
======================

   To run the `emacsclient' program, specify file names as arguments,
and optionally line numbers as well.  Do it like this:

     emacsclient {[+LINE[COLUMN]] FILENAME}...

This tells Emacs to visit each of the specified files; if you specify a
line number for a certain file, Emacs moves to that line in the file.
If you specify a column number as well, Emacs puts point on that column
in the line.

   Ordinarily, `emacsclient' does not return until you use the `C-x #'
command on each of these buffers.  When that happens, Emacs sends a
message to the `emacsclient' program telling it to return.

   But if you use the option `-n' or `--no-wait' when running
`emacsclient', then it returns immediately.  (You can take as long as
you like to edit the files in Emacs.)

   The option `--alternate-editor=COMMAND' is useful when running
`emacsclient' in a script.  It specifies a command to run if
`emacsclient' fails to contact Emacs.  For example, the following
setting for the EDITOR environment variable will always give an editor,
even if Emacs is not running:

     EDITOR="emacsclient --alternate-editor vi +%d %s"

The environment variable ALTERNATE_EDITOR has the same effect, but the
value of the `--alternate-editor' takes precedence.

   Alternatively, the file `etc/emacs.bash' defines a bash function
which will communicate with a running Emacs server, or start one if
none exists.


File: emacs,  Node: Hardcopy,  Next: PostScript,  Prev: Emacs Server,  Up: Top

Hardcopy Output
===============

   The Emacs commands for making hardcopy let you print either an entire
buffer or just part of one, either with or without page headers.  See
also the hardcopy commands of Dired (*note Misc File Ops::) and the
diary (*note Diary Commands::).

`M-x print-buffer'
     Print hardcopy of current buffer with page headings containing the
     file name and page number.

`M-x lpr-buffer'
     Print hardcopy of current buffer without page headings.

`M-x print-region'
     Like `print-buffer' but print only the current region.

`M-x lpr-region'
     Like `lpr-buffer' but print only the current region.

   The hardcopy commands (aside from the Postscript commands) pass extra
switches to the `lpr' program based on the value of the variable
`lpr-switches'.  Its value should be a list of strings, each string an
option starting with `-'.  For example, to specify a line width of 80
columns for all the printing you do in Emacs, set `lpr-switches' like
this:

     (setq lpr-switches '("-w80"))

   You can specify the printer to use by setting the variable
`printer-name'.

   The variable `lpr-command' specifies the name of the printer program
to run; the default value depends on your operating system type.  On
most systems, the default is `"lpr"'.  The variable
`lpr-headers-switches' similarly specifies the extra switches to use to
make page headers.  The variable `lpr-add-switches' controls whether to
supply `-T' and `-J' options (suitable for `lpr') to the printer
program: `nil' means don't add them.  `lpr-add-switches' should be
`nil' if your printer program is not compatible with `lpr'.


File: emacs,  Node: PostScript,  Next: PostScript Variables,  Prev: Hardcopy,  Up: Top

PostScript Hardcopy
===================

   These commands convert buffer contents to PostScript, either
printing it or leaving it in another Emacs buffer.

`M-x ps-print-buffer'
     Print hardcopy of the current buffer in PostScript form.

`M-x ps-print-region'
     Print hardcopy of the current region in PostScript form.

`M-x ps-print-buffer-with-faces'
     Print hardcopy of the current buffer in PostScript form, showing
     the faces used in the text by means of PostScript features.

`M-x ps-print-region-with-faces'
     Print hardcopy of the current region in PostScript form, showing
     the faces used in the text.

`M-x ps-spool-buffer'
     Generate PostScript for the current buffer text.

`M-x ps-spool-region'
     Generate PostScript for the current region.

`M-x ps-spool-buffer-with-faces'
     Generate PostScript for the current buffer, showing the faces used.

`M-x ps-spool-region-with-faces'
     Generate PostScript for the current region, showing the faces used.

`M-x handwrite'
     Generates/prints PostScript for the current buffer as if
     handwritten.

   The PostScript commands, `ps-print-buffer' and `ps-print-region',
print buffer contents in PostScript form.  One command prints the
entire buffer; the other, just the region.  The corresponding
`-with-faces' commands, `ps-print-buffer-with-faces' and
`ps-print-region-with-faces', use PostScript features to show the faces
(fonts and colors) in the text properties of the text being printed.

   If you are using a color display, you can print a buffer of program
code with color highlighting by turning on Font-Lock mode in that
buffer, and using `ps-print-buffer-with-faces'.

   The commands whose names have `spool' instead of `print' generate
the PostScript output in an Emacs buffer instead of sending it to the
printer.

   `M-x handwrite' is more frivolous.  It generates a PostScript
rendition of the current buffer as a cursive handwritten document.  It
can be customized in group `handwrite'.  This function only supports
ISO 8859-1 characters.

   The following section describes variables for customizing these
commands.


File: emacs,  Node: PostScript Variables,  Next: Sorting,  Prev: PostScript,  Up: Top

Variables for PostScript Hardcopy
=================================

   All the PostScript hardcopy commands use the variables
`ps-lpr-command' and `ps-lpr-switches' to specify how to print the
output.  `ps-lpr-command' specifies the command name to run,
`ps-lpr-switches' specifies command line options to use, and
`ps-printer-name' specifies the printer.  If you don't set the first
two variables yourself, they take their initial values from
`lpr-command' and `lpr-switches'.  If `ps-printer-name' is `nil',
`printer-name' is used.

   The variable `ps-print-header' controls whether these commands add
header lines to each page--set it to `nil' to turn headers off.

   If your printer doesn't support colors, you should turn off color
processing by setting `ps-print-color-p' to `nil'.  By default, if the
display supports colors, Emacs produces hardcopy output with color
information; on black-and-white printers, colors are emulated with
shades of gray.  This might produce illegible output, even if your
screen colors only use shades of gray.

   By default, PostScript printing ignores the background colors of the
faces, unless the variable `ps-use-face-background' is non-`nil'.  This
is to avoid unwanted interference with the zebra stripes and background
image/text.

   The variable `ps-paper-type' specifies which size of paper to format
for; legitimate values include `a4', `a3', `a4small', `b4', `b5',
`executive', `ledger', `legal', `letter', `letter-small', `statement',
`tabloid'.  The default is `letter'.  You can define additional paper
sizes by changing the variable `ps-page-dimensions-database'.

   The variable `ps-landscape-mode' specifies the orientation of
printing on the page.  The default is `nil', which stands for
"portrait" mode.  Any non-`nil' value specifies "landscape" mode.

   The variable `ps-number-of-columns' specifies the number of columns;
it takes effect in both landscape and portrait mode.  The default is 1.

   The variable `ps-font-family' specifies which font family to use for
printing ordinary text.  Legitimate values include `Courier',
`Helvetica', `NewCenturySchlbk', `Palatino' and `Times'.  The variable
`ps-font-size' specifies the size of the font for ordinary text.  It
defaults to 8.5 points.

   Emacs supports more scripts and characters than a typical PostScript
printer.  Thus, some of the characters in your buffer might not be
printable using the fonts built into your printer.  You can augment the
fonts supplied with the printer with those from the GNU Intlfonts
package, or you can instruct Emacs to use Intlfonts exclusively.  The
variable `ps-multibyte-buffer' controls this: the default value, `nil',
is appropriate for printing ASCII and Latin-1 characters; a value of
`non-latin-printer' is for printers which have the fonts for ASCII,
Latin-1, Japanese, and Korean characters built into them.  A value of
`bdf-font' arranges for the BDF fonts from the Intlfonts package to be
used for _all_ characters.  Finally, a value of `bdf-font-except-latin'
instructs the printer to use built-in fonts for ASCII and Latin-1
characters, and Intlfonts BDF fonts for the rest.

   To be able to use the BDF fonts, Emacs needs to know where to find
them.  The variable `bdf-directory-list' holds the list of directories
where Emacs should look for the fonts; the default value includes a
single directory `/usr/local/share/emacs/fonts/bdf'.

   Many other customization variables for these commands are defined and
described in the Lisp files `ps-print.el' and `ps-mule.el'.

